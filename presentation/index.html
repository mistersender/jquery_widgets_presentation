<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>Writing jQuery/jQuery Mobile Widgets</title>
	<meta name="description" content="A presentation on how to use the jQuery Widget factory to create widgets">
	<meta name="author" content="Jessica Kennedy">
	<meta name="apple-mobile-web-app-capable" content="yes" />
	<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
	<link rel="stylesheet" href="css/reveal.css">
	<link rel="stylesheet" href="css/theme/black.css" id="theme">
	<!-- Code syntax highlighting -->
	<link rel="stylesheet" href="lib/css/zenburn.css">
	<!-- Printing and PDF exports -->
	<script>
		var link = document.createElement( 'link' );
		link.rel = 'stylesheet';
		link.type = 'text/css';
		link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
		document.getElementsByTagName( 'head' )[0].appendChild( link );
	</script>
	<!--[if lt IE 9]>
	<script src="lib/js/html5shiv.js"></script>
	<![endif]-->
</head>
<body>
<div class="reveal">
<div class="slides">

<!-- Section 0: the obligatory stuff -->
<section>
 <h1>Writing jQuery Widgets</h1>
 <h3>with Jessica Kennedy</h3>
</section>

<section>
 Who am I?
 [insert sock drawer picture here]
</section>

<!-- Section 1: what is a widget -->
<section>
 <section>
  <h2>What is a Widget?</h2>
  <ul>
   <li class="fragment">A Stateful Plugin</li>
   <li class="fragment">Framework for writing stateful javascript</li>
  </ul>
  <!-- <img class="fragment" src="lib/images/confused_mal.gif"> -->
  <aside class="notes" data-markdown>
   At it's simplest... [a stateful plugin]

   The most common question I get is _"What's the difference between a plugin and a widget?"_
   It's a plugin, with _MORE!_

   Widget factory is a framework for writing stateful plugins.
   Tries to solve the various ways statfulness can be managed.
  </aside>
 </section>

 <section>
  <h3>jQuery UI Widget Factory</h3>
  <!-- @todo {!} make a sunburst for this -->
  <p>Fun Fact! jQuery Mobile is built on the Widget Factory</p>
  <h3 class="fragment">Framework Defines:</h3>
  <ul>
   <li class="fragment">Required Functions</li>
   <li class="fragment">How Callbacks are handled</li>
   <li class="fragment">How options are handled</li>
   <li class="fragment">Naming conventions</li>
  </ul>
  <aside class="notes" data-markdown>
   obviously a prototype of functions
  </aside>
 </section>
</section>

<section>
 <h3>Widgets Require:</h3>
 <ul>
  <li>jQuery ~82kb</li>
  <li>
    jQuery UI <b>-or-</b> jQuery Mobile
    <br>
    build with Widget Factory included ~24kb
  </li>
 </ul>
</section>

<section>
 <h3>You might want a widget if...</h3>
 <ul>
  <li class="fragment">You find yourself writing workarouds for a plugin</li>
  <li class="fragment">You know your application will need to maintain state</li>
  <li class="fragment">You want to add something with the word "mobile" to your resume</li>
 </ul>
 <!-- @todo {!} add pun husky img -->
</section>

<!-- section 2, the actual framework -->
<section>
 <h1>Widget Factory Framework</h1>
 <p>Where we make a Harry-Potter themed widget.</p>
 <aside class="notes" data-markdown>
  should
  * cast spells
 </aside>
</section>

<section>
 <h3>Boilerplate</h3>
 <p>Use a blank boilerplate widget to get started.</p>
 <a href="../01_boilerplate/" target="_blank">Check it out!</a>
 <aside class="notes" data-markdown>
  ```
  $("[data-boilerplate]").boilerplate();
  ```
 </aside>
</section>

<section>
 <h3>Namespacing</h3>

 <p>Widgets must contain a namespace as well as their name.</p>
 <pre><code>
  // where {} is the widget prototype
  $.widget("namespace.boilerplate", {});
 </code></pre>

 <p>The namespace is used to add data to the element for maintaining state.</p>
 <!-- @todo {!} add image of data-whatever-whatever instead of this lame code block -->
 <pre><code>
  data{
   namespace-boilerplate = {}
  }
 </code></pre>

 <p>Externally, the namespace is abstracted.</p>
 <pre><code>
  // instantiate boilerplate widget (see, no namespace!)
  $("#boilerplate").boilerplate();
 </code></pre>

 <aside class="notes" data-markdown>
  can only be 1 level deep.

  dash delimited for use in dataset

  see the data from the last example
  ```
  $("[data-boilerplate]").data();
  ```
 </aside>
</section>

<section>
 <h2>Give it a name!</h2>
 <h3 class="fragment">mf.spell()</mf>
 <aside class="notes">
  Our widget needs a name.
  Our widget is going to cast a spell,
  so let's call it `spell()`
 </aside>
</section>

<section>
 <pre><code>
  ;(function($, undefined){
   $.widget("mf.spell", {
   });
  })(jQuery);
 </code></pre>

 <p class="fragment">That's nice...<br> But it doesn't do anything!</p>
 <aside class="notes">
  always wrap in a closure, because best practices.

  But at this point, it doesn't do anything.
 </aside>
</section>

<section>
 <h3>What should it do?</h3>
 <ul>
  <li class="fragment">Cast a spell</li>
  <li class="fragment">make the spell have a variable strength</li>
 </ul>
 <aside class="notes">
  But that's boring. Let's let the spells have a strength.
 </aside>
</section>
<section>
 <section>
  <h3>Options</h3>
  <pre><code>
   $.widget("mf.spell", {
    // define out options for the widget, which are handled by the factory.
    options: {
     spellname: "",
     spellpower: 1
    }
   });
  </code></pre>
  <aside class="notes">
   widget factory expects options to be used.
   * should always define `options` in the prototype
   * defaults should be set here
   we have default options, but how do we override them?
  </aside>
 </section>

 <section>
  <h3>Overriding options</h3>
  <pre><code>
   $("#spellCaster2").spell({
    spellname: "Levicorpus",
    spellpower: 2
   });
  </code></pre>
  <aside class="notes">
   Factory handles setting overrides initially
   we have optoins, but what do we do with them?
  </aside>
 </section>
</section>

<section>
 <section>
  <h3>_create()</h3>
  <pre><code>
  $.widget("mf.spell", {
   // define out options for the widget, which are handled by the factory.
   options: {
    spellname: "",
    spellpower: 1
   },

   // called by the widget factory to kick off creation of the widget.
   _create: function(){
    var self = this;

    // Optional: override any option defaults with what we have in the data
    $.extend(self.options, self.element.data());
   }
  });
  </code></pre>
  <aside class="notes">
   * called by widget factory on .init()
   * should contain logic to set widget up
   * required for widget to do anything
   Let's look at each piece here a little more
  </aside>
 </section>

 <section>
  <h3>self</h3>
  <pre><code>
   var self = this;
  </code></pre>
  <p>"this" is the widget prototype</p>
  <aside class="notes" data-markdown>
   * where `this` = the widget code.
   * declare at top of all functions for sanity
  </aside>
 </section>

 <section>
  <h3>Another way to set options</h3>
  <pre><code>
   $.extend(self.options, self.element.data());
  </code></pre>

  <p>Then, at the bottom of your closure:</p>
  <pre><code>
   // have widget run immediately on page load using `data-`
   $(document).on("ready", function(e){
    $("body [data-spell]").spell();
   });
  </code></pre>
  <aside class="notes" data-markdown>
   * take second argument and merge into first
   * how jquery mobile operates ie `data-theme`
   * optional, but recommended for mobile widgets to stick with how jqm works

   * then, on *ready* OR *pageinit* call the widget
  </aside>
 </section>
</section>

<section>
 <h3>Set global variables</h3>
 <pre><code>
  _create: function(){
   var self = this;

   $.extend(self.options, self.element.data());

   // set all private variables the widget will use
   self.global = {
    score: 0,
    elem: {
     $last_cast: $("<aside class='spell-container__last_cast'></aside>"),
     $info: $("<aside class='spell-container__info'></aside>"),
     $score: $("<aside class='spell-container__score'>0</aside>"),
     $wand: $("<figure class='spell-container__wand'>Wand</figure>")
    }
   };
  }
 </code></pre>
 <aside class="notes" data-markdown>
  do yourself a favor.
  if it's global, slap it in `self.global`.

  I always set my global variables next.

  I usually cache any elements I am creating/manipulating into the local global scope as well.

  Note: reveal freaked out, you don't need the closing `aside` tags irl.

  So this is great, but it hasn't actually *done* anything to the user yet.
 </aside>
</section>

<section>
 <section>
  <h3>_build()</h3>
  <p>(Not part of factory)</p>
  <pre><code>
   _create: function(){
    var self = this;

    $.extend(self.options, self.element.data());

    self.global = { .. };

    // do any additional things that need to happen to set up the widget, such as adding additional elements to the page or binding events.
    self._build();
   },
  </code></pre>
  <aside class="notes">
   not a part of widget factory, just something i do.
   can be a lot of code, easier to separate.

   `_` forces function to be private.

   and since you're here to learn from me, you get to know what i would do! luckyyyy
  </aside>
 </section>

 <section>
  <pre><code>
   _build: function(){
    var self = this;

    // set up the info on the spell we are casting
    self.global.elem.$info.html("<b class='spell_container__name'>" + self.options.spellname + "</b> " + "<span class='spell_container__power'>" + self.options.spellpower + "</span>");

    // Add a class to our container
    self.element
     .addClass("spell-container spell-container--" + self.options.spellname.replace(" ", "-", "all"))
     // now let's add our globally cached elements to the widget.
     .append(self.global.elem.$info, self.global.elem.$last_cast, self.global.elem.$score, self.global.elem.$wand);
   }
  </code></pre>
 </section>
</section>

<section>
 <h2>It's doing something!</h2>
 <a href="../02_create/" target="_blank">Check it out!</a>
 <p class="fragment">Thanks to <a href="codepen.io">Brandon Kennedy</a> for this baller css.</p>
 <aside class="notes">
  That's great! But it's not doing much.

  It still doesn't cast a spell.
 </aside>
</section>

</div><!-- end slides div -->
</div><!-- end reveal div -->

<script src="lib/js/head.min.js"></script>
<script src="js/reveal.js"></script>
<script>
	// Full list of configuration options available at:
	// https://github.com/hakimel/reveal.js#configuration
	Reveal.initialize({
		controls: true,
		progress: true,
		history: true,
		center: true,

		transition: 'slide', // none/fade/slide/convex/concave/zoom

		// Optional reveal.js plugins
		dependencies: [
			{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
			{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
			{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
			{ src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
			{ src: 'plugin/zoom-js/zoom.js', async: true },
			{ src: 'plugin/notes/notes.js', async: true }
		]
	});
</script>

</body>
</html>
